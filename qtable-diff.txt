--- src/core/learning/QTable.ts	2026-01-09 13:47:05
+++ src/domains/intelligence/aggregates/q-table.ts	2026-01-11 01:57:02
@@ -1,131 +1,158 @@
 /**
- * ELEX Edge AI Agent Swarm - Q-Table Implementation
+ * QTable Aggregate Root
  *
- * Q-learning state-action value table for agent self-improvement.
- * Implements the Q-learning update rule:
- * Q(s,a) <- Q(s,a) + alpha[r + gamma * max(Q(s',a')) - Q(s,a)]
+ * Stores learned state-action values for Q-learning.
+ * This is the main learning data structure for the Intelligence context.
  */
 
-import type {
-  State,
-  Reward,
-  QValue,
-  QEntry,
-  ConfidenceScore,
-  DiscountFactor,
-  LearningRate,
-  ExplorationRate,
-} from '../types/index.js';
-import { Action, calculateTotalReward } from '../types/index.js';
+import { State } from '../value-objects/state';
+import { Action, ALL_ACTIONS, ACTION_METADATA } from '../value-objects/action';
+import { Reward } from '../value-objects/reward';
+import { QEntry } from '../entities/q-entry';
 
-/**
- * Q-Table configuration
- */
 export interface QTableConfig {
-  gamma?: DiscountFactor;   // Discount factor (default: 0.95)
-  alpha?: LearningRate;     // Learning rate (default: 0.1)
-  epsilon?: ExplorationRate; // Exploration rate (default: 0.1)
-  epsilonDecay?: number;    // Epsilon decay rate (default: 0.995)
-  minEpsilon?: number;      // Minimum epsilon (default: 0.01)
+  readonly gamma: number;   // Discount factor (default: 0.95)
+  readonly alpha: number;   // Learning rate (default: 0.1)
+  readonly epsilon: number; // Exploration rate (default: 0.1)
 }
 
-/**
- * State-Action key generator
- */
-function createStateActionKey(state: State, action: Action): string {
-  return `${state.queryType}:${state.complexity}:${state.contextHash}:${action}`;
+export interface StateActionKey {
+  readonly stateKey: string;
+  readonly action: Action;
 }
 
 /**
- * State key generator (for max Q value lookup)
+ * Domain Events for QTable
  */
-function createStateKey(state: State): string {
-  return `${state.queryType}:${state.complexity}:${state.contextHash}`;
+export interface QTableUpdated {
+  readonly type: 'QTableUpdated';
+  readonly qTableId: string;
+  readonly stateKey: string;
+  readonly action: Action;
+  readonly newQValue: number;
+  readonly timestamp: Date;
 }
 
+export interface QTableMerged {
+  readonly type: 'QTableMerged';
+  readonly qTableId: string;
+  readonly peerId: string;
+  readonly mergedEntries: number;
+  readonly timestamp: Date;
+}
+
+export type QTableEvent = QTableUpdated | QTableMerged;
+
 /**
- * Q-Table
- *
- * Maintains state-action values for Q-learning.
- * Features:
- * - Epsilon-greedy action selection
- * - Adaptive learning rate
- * - Confidence tracking
- * - Federated merge support
+ * QTable Aggregate Root
  */
 export class QTable {
-  private readonly config: Required<QTableConfig>;
+  readonly id: string;
+  readonly agentId: string;
+  private _gamma: number;
+  private _alpha: number;
+  private _epsilon: number;
+  private _entries: Map<string, QEntry>;
+  private _events: QTableEvent[];
 
-  // Q-values storage: state-action key -> QEntry
-  private readonly entries = new Map<string, QEntry>();
+  constructor(
+    id: string,
+    agentId: string,
+    config: QTableConfig = { gamma: 0.95, alpha: 0.1, epsilon: 0.1 }
+  ) {
+    this.id = id;
+    this.agentId = agentId;
+    this._gamma = config.gamma;
+    this._alpha = config.alpha;
+    this._epsilon = config.epsilon;
+    this._entries = new Map();
+    this._events = [];
+  }
 
-  // State index: state key -> Set of action keys
-  private readonly stateIndex = new Map<string, Set<string>>();
-
-  // Current epsilon for exploration
-  private currentEpsilon: ExplorationRate;
-
-  // Statistics
-  private totalUpdates: number = 0;
-  private totalSelections: number = 0;
-
-  constructor(config: QTableConfig = {}) {
-    this.config = {
-      gamma: config.gamma ?? 0.95,
-      alpha: config.alpha ?? 0.1,
-      epsilon: config.epsilon ?? 0.1,
-      epsilonDecay: config.epsilonDecay ?? 0.995,
-      minEpsilon: config.minEpsilon ?? 0.01,
-    };
-
-    this.currentEpsilon = this.config.epsilon;
+  /**
+   * Look up Q-value for a state-action pair
+   */
+  lookup(state: State, action: Action): number {
+    const entry = this.getEntry(state, action);
+    return entry?.qValue ?? 0;
   }
 
   /**
-   * Initialize the Q-table (async for compatibility)
+   * Get confidence for a state-action pair
    */
-  async initialize(): Promise<void> {
-    // Pre-populate with initial Q-values for all actions
-    // This helps with cold start
+  getConfidence(state: State, action: Action): number {
+    const entry = this.getEntry(state, action);
+    return entry?.confidence ?? 0;
   }
 
   /**
-   * Select action using epsilon-greedy policy
+   * Update Q-value based on experience
    */
-  async selectAction(state: State): Promise<Action> {
-    this.totalSelections++;
+  update(state: State, action: Action, reward: Reward, nextState: State): void {
+    const key = this.makeKey(state, action);
+    let entry = this._entries.get(key);
 
+    if (!entry) {
+      entry = new QEntry();
+      this._entries.set(key, entry);
+    }
+
+    // Find max Q-value for next state
+    const nextMaxQ = this.getMaxQ(nextState);
+
+    // Update the entry
+    entry.update(reward.total(), nextMaxQ, this._alpha, this._gamma);
+
+    this.raise({
+      type: 'QTableUpdated',
+      qTableId: this.id,
+      stateKey: state.toKey(),
+      action,
+      newQValue: entry.qValue,
+      timestamp: new Date()
+    });
+  }
+
+  /**
+   * Select best action for a state (with epsilon-greedy exploration)
+   */
+  selectAction(state: State, explore: boolean = true): Action {
     // Epsilon-greedy exploration
-    if (Math.random() < this.currentEpsilon) {
-      return this.randomAction();
+    if (explore && Math.random() < this._epsilon) {
+      return ALL_ACTIONS[Math.floor(Math.random() * ALL_ACTIONS.length)];
     }
 
-    // Exploit: choose best action
-    return this.bestAction(state);
+    // Greedy selection
+    return this.getBestAction(state);
   }
 
   /**
-   * Get the best action for a state (greedy)
+   * Get the best action for a state (pure exploitation)
    */
-  bestAction(state: State): Action {
-    const stateKey = createStateKey(state);
-    const actionKeys = this.stateIndex.get(stateKey);
+  getBestAction(state: State): Action {
+    let bestAction = ALL_ACTIONS[0];
+    let bestValue = Number.NEGATIVE_INFINITY;
+    const values = new Map<Action, number>();
 
-    if (!actionKeys || actionKeys.size === 0) {
-      // No experience, return default action
-      return Action.DirectAnswer;
+    for (const action of ALL_ACTIONS) {
+      const value = this.lookup(state, action);
+      values.set(action, value);
+      if (value > bestValue) {
+        bestValue = value;
+        bestAction = action;
+      }
     }
 
-    let bestAction: Action = Action.DirectAnswer;
-    let bestValue = -Infinity;
-
-    for (const actionKey of actionKeys) {
-      const entry = this.entries.get(actionKey);
-      if (entry && entry.qValue > bestValue) {
-        bestValue = entry.qValue;
-        // Extract action from key
-        const parts = actionKey.split(':');
-        bestAction = parts[parts.length - 1] as Action;
+    // If all values are equal (all 0 for unvisited states),
+    // prefer actions with lower base cost (DIRECT_ANSWER has cost 0)
+    if (bestValue === 0) {
+      let lowestCost = Number.POSITIVE_INFINITY;
+      for (const action of ALL_ACTIONS) {
+        const metadata = ACTION_METADATA.get(action);
+        if (metadata && metadata.baseCost < lowestCost) {
+          lowestCost = metadata.baseCost;
+          bestAction = action;
+        }
       }
     }
 
@@ -133,236 +160,122 @@
   }
 
   /**
-   * Lookup Q-value for a state-action pair
+   * Get maximum Q-value for a state across all actions
    */
-  lookup(state: State, action: Action): QValue {
-    const key = createStateActionKey(state, action);
-    const entry = this.entries.get(key);
-    return entry?.qValue ?? 0;
+  getMaxQ(state: State): number {
+    let maxQ = Number.NEGATIVE_INFINITY;
+
+    for (const action of ALL_ACTIONS) {
+      const q = this.lookup(state, action);
+      if (q > maxQ) {
+        maxQ = q;
+      }
+    }
+
+    return maxQ === Number.NEGATIVE_INFINITY ? 0 : maxQ;
   }
 
   /**
-   * Update Q-value using Q-learning rule
+   * Merge with another Q-table (for federated learning)
    */
-  update(state: State, action: Action, reward: Reward, nextState: State): void {
-    const key = createStateActionKey(state, action);
-    const stateKey = createStateKey(state);
-    const totalReward = calculateTotalReward(reward);
+  merge(peerQTable: QTable): void {
+    let mergedCount = 0;
 
-    // Get or create entry
-    let entry = this.entries.get(key);
-    if (!entry) {
-      entry = {
-        qValue: 0,
-        visits: 0,
-        confidence: 0,
-        outcomes: { successes: 0, failures: 0, totalReward: 0 },
-        lastUpdated: Date.now(),
-      };
-      this.entries.set(key, entry);
+    for (const [key, peerEntry] of peerQTable._entries) {
+      const localEntry = this._entries.get(key);
 
-      // Update state index
-      if (!this.stateIndex.has(stateKey)) {
-        this.stateIndex.set(stateKey, new Set());
+      if (localEntry) {
+        // Merge existing entries
+        const mergedEntry = localEntry.merge(peerEntry);
+        this._entries.set(key, mergedEntry);
+      } else {
+        // Add new entries from peer
+        this._entries.set(key, new QEntry(
+          peerEntry.qValue,
+          peerEntry.visits,
+          peerEntry.confidence,
+          [...peerEntry.outcomes],
+          peerEntry.lastUpdated
+        ));
       }
-      this.stateIndex.get(stateKey)!.add(key);
+      mergedCount++;
     }
 
-    // Calculate max Q(s', a')
-    const maxNextQ = this.maxQValue(nextState);
-
-    // Q-learning update
-    const oldQ = entry.qValue;
-    const newQ = oldQ + this.config.alpha * (totalReward + this.config.gamma * maxNextQ - oldQ);
-
-    // Update entry
-    entry.qValue = newQ;
-    entry.visits++;
-    entry.lastUpdated = Date.now();
-    entry.outcomes.totalReward += totalReward;
-
-    if (totalReward > 0) {
-      entry.outcomes.successes++;
-    } else if (totalReward < 0) {
-      entry.outcomes.failures++;
-    }
-
-    // Update confidence based on visits
-    entry.confidence = this.calculateConfidence(entry.visits);
-
-    // Decay epsilon
-    this.decayEpsilon();
-
-    this.totalUpdates++;
+    this.raise({
+      type: 'QTableMerged',
+      qTableId: this.id,
+      peerId: peerQTable.agentId,
+      mergedEntries: mergedCount,
+      timestamp: new Date()
+    });
   }
 
   /**
-   * Get confidence for a state-action pair
+   * Decay epsilon over time (for annealing exploration)
    */
-  getConfidence(state: State, action: Action): ConfidenceScore {
-    const key = createStateActionKey(state, action);
-    const entry = this.entries.get(key);
-    return entry?.confidence ?? 0;
+  decayEpsilon(factor: number = 0.995, minEpsilon: number = 0.01): void {
+    this._epsilon = Math.max(minEpsilon, this._epsilon * factor);
   }
 
   /**
-   * Get average confidence across all entries
+   * Get entry for state-action pair
    */
-  getAverageConfidence(): ConfidenceScore {
-    if (this.entries.size === 0) {
-      return 0.5;
-    }
-
-    let totalConfidence = 0;
-    for (const entry of this.entries.values()) {
-      totalConfidence += entry.confidence;
-    }
-
-    return totalConfidence / this.entries.size;
+  private getEntry(state: State, action: Action): QEntry | undefined {
+    return this._entries.get(this.makeKey(state, action));
   }
 
   /**
-   * Merge with peer Q-table using weighted average
+   * Create map key from state and action
    */
-  merge(peerEntries: Map<string, QEntry>): void {
-    for (const [key, peerEntry] of peerEntries) {
-      const localEntry = this.entries.get(key);
-
-      if (!localEntry) {
-        // New entry from peer
-        this.entries.set(key, { ...peerEntry });
-
-        // Update state index
-        const parts = key.split(':');
-        const stateKey = parts.slice(0, -1).join(':');
-        if (!this.stateIndex.has(stateKey)) {
-          this.stateIndex.set(stateKey, new Set());
-        }
-        this.stateIndex.get(stateKey)!.add(key);
-      } else {
-        // Merge using weighted average
-        const totalVisits = localEntry.visits + peerEntry.visits;
-        if (totalVisits > 0) {
-          const mergedQ =
-            (localEntry.qValue * localEntry.visits + peerEntry.qValue * peerEntry.visits) /
-            totalVisits;
-
-          // Only merge if significant difference
-          const difference = Math.abs(localEntry.qValue - peerEntry.qValue);
-          if (difference > 0.1) {
-            localEntry.qValue = mergedQ;
-            localEntry.visits = Math.max(localEntry.visits, peerEntry.visits);
-            localEntry.confidence = this.calculateConfidence(localEntry.visits);
-            localEntry.lastUpdated = Date.now();
-
-            // Merge outcomes
-            localEntry.outcomes.successes += peerEntry.outcomes.successes;
-            localEntry.outcomes.failures += peerEntry.outcomes.failures;
-            localEntry.outcomes.totalReward += peerEntry.outcomes.totalReward;
-          }
-        }
-      }
-    }
+  private makeKey(state: State, action: Action): string {
+    return `${state.toKey()}:${action}`;
   }
 
-  /**
-   * Export entries for federated sync
-   */
-  export(): Map<string, QEntry> {
-    return new Map(this.entries);
+  private raise(event: QTableEvent): void {
+    this._events.push(event);
   }
 
-  /**
-   * Get Q-table statistics
-   */
-  getStats(): {
-    totalEntries: number;
-    totalUpdates: number;
-    totalSelections: number;
-    currentEpsilon: number;
-    averageQValue: number;
-    averageVisits: number;
-  } {
-    let totalQ = 0;
-    let totalVisits = 0;
+  // Getters
+  get gamma(): number { return this._gamma; }
+  get alpha(): number { return this._alpha; }
+  get epsilon(): number { return this._epsilon; }
+  get entryCount(): number { return this._entries.size; }
 
-    for (const entry of this.entries.values()) {
-      totalQ += entry.qValue;
-      totalVisits += entry.visits;
-    }
-
-    const count = this.entries.size || 1;
-
-    return {
-      totalEntries: this.entries.size,
-      totalUpdates: this.totalUpdates,
-      totalSelections: this.totalSelections,
-      currentEpsilon: this.currentEpsilon,
-      averageQValue: totalQ / count,
-      averageVisits: totalVisits / count,
-    };
-  }
-
   /**
-   * Clear all entries
+   * Get all entries as array
    */
-  clear(): void {
-    this.entries.clear();
-    this.stateIndex.clear();
-    this.currentEpsilon = this.config.epsilon;
-    this.totalUpdates = 0;
-    this.totalSelections = 0;
+  get entries(): Array<{ key: string; entry: QEntry }> {
+    return Array.from(this._entries.entries()).map(([key, entry]) => ({ key, entry }));
   }
 
-  // =========================================================================
-  // Private Methods
-  // =========================================================================
-
   /**
-   * Get maximum Q-value for a state
+   * Get and clear uncommitted domain events
    */
-  private maxQValue(state: State): QValue {
-    const stateKey = createStateKey(state);
-    const actionKeys = this.stateIndex.get(stateKey);
-
-    if (!actionKeys || actionKeys.size === 0) {
-      return 0;
-    }
-
-    let maxQ = -Infinity;
-    for (const actionKey of actionKeys) {
-      const entry = this.entries.get(actionKey);
-      if (entry && entry.qValue > maxQ) {
-        maxQ = entry.qValue;
-      }
-    }
-
-    return maxQ === -Infinity ? 0 : maxQ;
+  getUncommittedEvents(): QTableEvent[] {
+    const events = [...this._events];
+    this._events = [];
+    return events;
   }
 
   /**
-   * Select random action for exploration
+   * Identity equality
    */
-  private randomAction(): Action {
-    const actions = Object.values(Action);
-    return actions[Math.floor(Math.random() * actions.length)];
+  equals(other: QTable): boolean {
+    return this.id === other.id;
   }
 
-  /**
-   * Calculate confidence from visit count
-   * confidence = 1 - 1/(visits + 1)
-   */
-  private calculateConfidence(visits: number): ConfidenceScore {
-    return 1 - 1 / (visits + 1);
+  toString(): string {
+    return `QTable(${this.id}, entries=${this._entries.size}, eps=${this._epsilon.toFixed(3)})`;
   }
 
-  /**
-   * Decay exploration rate
-   */
-  private decayEpsilon(): void {
-    this.currentEpsilon = Math.max(
-      this.config.minEpsilon,
-      this.currentEpsilon * this.config.epsilonDecay
-    );
+  toJSON(): object {
+    return {
+      id: this.id,
+      agentId: this.agentId,
+      gamma: this._gamma,
+      alpha: this._alpha,
+      epsilon: this._epsilon,
+      entryCount: this._entries.size
+    };
   }
 }
